---
title: Bridge
---

import {
  DiscordButton,
  DiscordButtons,
  DiscordInteraction,
  DiscordMessage,
  DiscordMessages,
} from "@discord-message-components/react";
import "@discord-message-components/react/styles";

## Concept

Let's say that you want to make a command that is both a Slash Command and a Prefixed Command. Now, you could just copy and paste the code from the first command callback to the other and make some adjustments, but that's not very efficient.

This is where the `ext.bridge` comes in. It allows you to use one callback to make both a Slash Command and a Prefixed Command.

:::note
Currently, `ext.bridge` has not been merged to the main branch yet and it's somewhat experimental. So in order to use it, you'll have to install the `py-cord` package from the `ext-compat` branch by running this:
```
pip install git+https://github.com/Pycord-Development/pycord.git@ext-compat
```
:::

### Example Usage

```python
import discord
from discord.ext import bridge

bot = bridge.Bot(command_prefix="!")

@bot.bridge_command()
async def hello(ctx):
  await ctx.respond("Hello!")

bot.run("TOKEN")
```

<DiscordMessages>
  <DiscordMessage author="Guide Bot" avatar="red" bot>
    <div slot="interactions">
      <DiscordInteraction author="Guide Man" avatar="green" command>
        hello
      </DiscordInteraction>
    </div>
    Hello!
  </DiscordMessage>

  <DiscordMessage author="Guide Man" avatar="green">
    !hello
  </DiscordMessage>

  <DiscordMessage author="Guide Bot" avatar="red" bot>
    Hello!
  </DiscordMessage>
</DiscordMessages>

## Syntax

First, instead of using `discord.Bot` or `commands.Bot`, we use `bridge.Bot`. `bridge.Bot` does inherit from `commands.Bot`, so you can do anything with `bridge.Bot` that `commands.Bot` can do.
Then, we define a command with `@bot.bridge_command()`. This makes a Bridge Command, which has both a Prefixed Command counterpart and a Slash Command counterpart.
Next, the callback has access to a `ctx` object, which is the context of the command. This context is either of `BridgeApplicationContext` type or `BridgeExtContext`. Because of that, it makes detecting how the function was called easier.

### Using Bridge Commands in a Cog

Like Slash Commands and Prefixed Commands, you can use Bridge Commands in a Cog. You can do this by using the `bridge_command` decorator. Here's an example:

```python
import discord
from discord.ext import commands
from discord.ext import bridge

class Greetings(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @bridge.bridge_command()
    async def hello(ctx):
        await ctx.respond("Hello!")

    @bridge.bridge_command()
    async def bye(ctx):
        await ctx.respond("Bye!")
```

The cog will automatically split the Bridge Command into their Slash Command and Prefixed Command counterparts.

<DiscordMessages>
  <DiscordMessage author="Guide Bot" avatar="red" bot>
    <div slot="interactions">
      <DiscordInteraction author="Guide Man" avatar="green" command>
        hello
      </DiscordInteraction>
    </div>
    Hello!
  </DiscordMessage>

  <DiscordMessage author="Guide Man" avatar="green">
    !hello
  </DiscordMessage>

  <DiscordMessage author="Guide Bot" avatar="red" bot>
    Hello!
  </DiscordMessage>

  <DiscordMessage author="Guide Bot" avatar="red" bot>
    <div slot="interactions">
      <DiscordInteraction author="Guide Man" avatar="green" command>
        bye
      </DiscordInteraction>
    </div>
    Bye!
  </DiscordMessage>

  <DiscordMessage author="Guide Man" avatar="green">
    !bye
  </DiscordMessage>

  <DiscordMessage author="Guide Bot" avatar="red" bot>
    Bye!
  </DiscordMessage>
</DiscordMessages>

<!-- TODO: Section about options -->
